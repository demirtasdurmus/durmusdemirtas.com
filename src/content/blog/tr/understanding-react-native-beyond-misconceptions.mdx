---
title: React Native'i Anlamak - Yanlış Bilgilerin Ötesinde
description: React Native'in native koda derlendiği efsanesini çürütüyor ve JSI, Hermes ve çoklu thread runtime ile gerçek mimarisini keşfediyoruz.
image: /images/blog/react-native-architecture.webp
date: '2025-12-16'
authors:
  - durmus-demirtas
---

React Native hakkındaki en yaygın efsanelerden biri, "JavaScript'i native koda derlediği" düşüncesidir. Bu fikir çekici görünse de, temelde yanlıştır ve genellikle ekipleri mimari, performans ve debug konularında yanlış varsayımlara yönlendirir.

React Native, JavaScript kodunuzu Swift, Objective-C, Kotlin veya Java'ya dönüştürmez. Bunun yerine, JavaScript'inizi özel bir engine içinde çalıştırır ve gerçek native UI bileşenlerini kontrol etmek için gelişmiş bir iletişim katmanı kullanır. Kodunuz yaşam döngüsü boyunca JavaScript (veya bytecode) olarak kalırken, platform iOS ve Android'de gerçek native view'ları render eder.

Bu ayrımı anlamak, React Native'i değerlendirirken, uygulama mimarisi tasarlarken veya performansı optimize ederken kritik öneme sahiptir.

### Çoklu Thread Mimarisi

React Native, farklı sorumlulukların kasıtlı olarak ayrı thread'lerde ayrıldığı çoklu thread bir runtime'a dayanır. Bu tasarım, JavaScript'in uygulama mantığını koordine etmesine izin verirken UI'ın yanıt vermesini sağlar.

1. **JavaScript Thread:** Tüm uygulama mantığınızın çalıştığı yerdir: React render'ları, state güncellemeleri, iş kuralları, API çağrıları, timer'lar ve JavaScript'in kontrol ettiği her şey. Native UI thread'inden bağımsız olarak çalışır.

2. **UI Thread (Ana Thread):** Platform'un native rendering ortamıdır, iOS'ta UIKit ve Android'de Android View sistemi. Pürüzsüz kaydırma, jestler ve animasyonları korumak için son derece yanıt vermesi gerekir. React Native UI güncellemelerini JavaScript thread'inden planlar, ancak gerçek rendering işi tamamen bu thread'deki native kodda gerçekleştirilir.

3. **Native Modules Thread:** Kamera, dosya sistemi, network stack'leri, sensörler veya herhangi bir özel native modül gibi platforma özel işlemler burada çalışır. Bu ayrım, pahalı native işlemlerin UI'ı bloke etmesini önler.

4. **Shadow Tree / Layout Sistemi:** Eski mimaride, layout hesaplamaları React Native'in cross-platform Flexbox engine'i olan Yoga kullanılarak ayrı bir Shadow Thread'de ele alınıyordu. Yeni Fabric mimarisi altında, layout birleşik ve daha senkron bir rendering pipeline'ına entegre edilmiştir, bu da gecikmeyi azaltır ve platformlar arası tutarlılığı artırır.

Tarihsel olarak, bu thread'ler asenkron **Bridge** aracılığıyla iletişim kuruyordu, bu da mesajları JSON'a serialize ediyor ve thread sınırları arasında iletiyordu.

[Yeni mimari](https://reactnative.dev/architecture/landing-page) bu asenkron bridge'i **JSI (JavaScript Interface)** ile değiştirir. Bu, JSON serialization ihtiyacını ortadan kaldıran hafif bir C++ katmanıdır ve şunları sağlar:

- Native objelere doğrudan erişim
- Senkron çağrılar
- Dramatik olarak azaltılmış serialization overhead'i

Bu değişim, modern React Native uygulamalarının eski mimariye sahip muadillerinden önemli ölçüde daha akıcı hissetmesinin ve daha hızlı başlamasının temel nedenlerinden biridir.

### JavaScript Bundle: Uygulamanızın Kalbi

Her React Native uygulamasının merkezinde **JavaScript bundle** bulunur, bu tüm bileşenlerinizi, iş mantığınızı ve bağımlılıklarınızı içeren, tamamen minify edilmiş ve paketlenmiş tek bir dosyadır. Uygulamanızı App Store veya Play Store için build ettiğinizde, bu bundle (genellikle iOS'ta `main.jsbundle` veya Android'de `index.android.bundle`) native binary ile birlikte gönderilir.

![main.jsbundle as plain text](/images/blog/mainjs-bundle-text.webp)

[Hermes](https://reactnative.dev/docs/hermes) kullanan modern React Native kurulumlarında, bu bundle düz JavaScript metni olarak gönderilmez. Bunun yerine, build süreci kaynak kodunuzu **Hermes bytecode**'a derler, bu Hermes engine'inin ham JavaScript'ten çok daha hızlı çalıştırabileceği kompakt ve optimize edilmiş bir formattır.

Geleneksel engine'ler JavaScript kaynak kodunu runtime'da parse eder, bu da uygulama başlangıcını yavaşlatır. Hermes bunu, ahead-of-time (AOT) derleme gerçekleştirerek önler: build süreci sırasında JavaScript kaynağınız kompakt Hermes bytecode'una dönüştürülür.

Başlatmada, engine bu bytecode'u doğrudan yükler, parsing adımını ortadan kaldırır ve başlangıç performansını önemli ölçüde iyileştirir. Uygulamalar genellikle daha hızlı cold start'lar, azaltılmış bellek kullanımı ve düz JavaScript eşdeğerlerinden %20–30 daha küçük bytecode bundle'ları görür.

<Callout>
  **Hermes** özellikle mobil kısıtlamalar için tasarlandı: sınırlı bellek, batarya bilinçli CPU
  kullanımı ve hızlı başlangıç gereksinimleri. Desktop tarayıcı senaryoları için optimize eden V8
  (Chrome'un engine'i) veya JavaScriptCore (Safari'nin engine'i) gibi engine'lerin aksine, Hermes
  mobil deneyimi baştan önceliklendirir.
</Callout>

![main.jsbundle compiled with Hermes bytecode](/images/blog/mainjs-bundle-hermes.webp)

Bu bundle, runtime başlangıçta onu yüklediği anda çalıştırılır. Kod, kendi engine'i içinde çalışan JavaScript (veya bytecode) olarak kalır ve gerçek native UI bileşenlerinin oluşturulmasını ve güncellenmesini orkestra eder.

### Bundle Odaklı Modelin Sağladıkları

JavaScript bundle'ın nasıl çalıştığını anlamak sadece resmin bir parçasıdır; gerçek önemi bu mimarinin sağladıklarından gelir:

- **Cross-Platform Geliştirme:** Tek bir JavaScript codebase'i hem iOS hem de Android uygulamalarını çalıştırır. Platforma özel kod gerektiğinde ayrı native modüllerde yaşar, ancak mantığınızın, UI'ınızın ve iş kurallarınızın büyük çoğunluğu paylaşılır.

- **Dinamik Davranış:** JavaScript, derlenmiş dillerle elde edilmesi zor olan bir runtime esnekliği seviyesi sağlar, API verilerine dayalı ekran render etme, runtime'da modül yükleme ve gelişmiş deney framework'lerini destekleme dahil.

- **Over-the-Air Güncellemeler:** CodePush gibi servisler, JavaScript bundle güncellemelerini app store onayı olmadan doğrudan kullanıcılara teslim edebilir. Production'da kritik bug'ları anında düzeltin, farklı bundle versiyonlarıyla A/B testleri çalıştırın veya özellikleri kademeli olarak yayınlayın, hepsi geleneksel uygulama deployment döngüleri olmadan.

- **Brownfield Entegrasyonu:** Native uygulamalar React Native'i bir framework olarak gömebilir, belirli ekranlar için JavaScript bundle'ları yükleyebilir. Bu, tüm uygulamayı yeniden yazmadan native'den React Native'e kademeli geçişi mümkün kılar.

- **Hızlı İterasyon ve Hot Reload:** Kodunuz JavaScript olduğu için, Fast Refresh gibi geliştirme workflow'ları native kodu yeniden derlemeden çalışan uygulamanızı anında güncelleyebilir. Bir bileşeni değiştirin, dosyayı kaydedin ve sonuçları bir saniyenin altında görün.

### Dikkate Alınması Gereken Trade-off'lar

Bu güçlü yönler, JavaScript bundle modelini modern React Native'in tanımlayıcı bir yönü haline getirir. Ancak herhangi bir mimari yaklaşım gibi, trade-off'ları vardır:

- **Performans Overhead'i:** JavaScript ve native katmanlar arasındaki her etkileşim bir maliyet getirir. JSI eski bridge'e kıyasla bu overhead'i dramatik olarak azaltırken, hala pure native koddan daha fazla latency vardır. Yüksek frekanslı olaylar (hızlı kaydırma, karmaşık animasyonlar, jest işleme) bu sınırlamaları ortaya çıkarabilir.

- **Bundle Boyutu Endişeleri:** Bir JavaScript engine'i göndermek binary'ye yaklaşık 3–5 MB ekler. JavaScript codebase'iniz büyüdükçe, bundle'ın kendisi minification ve compression'dan sonra bile birkaç megabayt daha ekleyebilir. Görseller, fontlar ve diğer asset'lerle birleştirildiğinde, React Native uygulamaları genellikle pure native eşdeğerlerinden %30–40 daha büyük olur.

- **Başlangıç Süresi:** JavaScript engine'ini başlatmak uygulama başlatma sırasında ek iş getirir. Hermes bytecode ile bile, engine yüklenmeli, bundle'ı çalıştırmalı ve UI görünmeden önce ilk React tree'sini oluşturmalıdır. Pratikte, iyi optimize edilmiş React Native uygulamaları genellikle 1 ila 2 saniye içinde başlar, daha az optimize edilmiş kurulumlar ise fark edilir şekilde daha uzun sürebilir.

- **Sınırlı Native Modül Ekosistemi:** Bazı platforma özel yetenekler hala özel native modüller gerektirir, bu da bakımı yapılan bir kütüphane olmadığında Swift, Objective-C, Kotlin veya Java yazmak anlamına gelir. Bu karmaşıklık ekler ve platformlar arasında paylaşabileceğiniz kod miktarını azaltır. Gelişmiş kamera kontrolleri, Bluetooth entegrasyonları veya video işleme gibi özellikler genellikle önemli native geliştirme gerektirir.

- **Debug Karmaşıklığı:** JavaScript ve native kod arasındaki sınırda meydana gelen sorunlar teşhis etmek zor olabilir. Stack trace'ler sıklıkla birden fazla dili kapsar, performans profiling platforma özel araçlarla yapılır ve bellek sızıntıları JavaScript tarafında veya native modüller içinde kaynaklanabilir. Etkili debug genellikle her iki ortam arasında bağlam değiştirmeyi gerektirir.

### Sonuç: Native Performans ile JavaScript Gücü

React Native, JavaScript'i native koda derleyerek değil, JavaScript'in verimli bir iletişim katmanı aracılığıyla gerçek native UI bileşenlerini orkestra ettiği bir mimari sağlayarak başarılı olur. JavaScript bundle uygulamanın merkezi mantığı olarak hareket eder ve JSI ile birlikte Hermes, native sistemlerle hızlı ve doğrudan etkileşimi sağlar.

Bu execution modelini anlamak doğru mimariyi seçmek için gereklidir. React Native, içerik odaklı arayüzler, form ağırlıklı uygulamalar ve hızlı iterasyon gerektiren ürünler için güçlü avantajlar sunar. Gelişmiş grafikler veya gerçek zamanlı işleme gibi performans yoğun işler genellikle native kodda daha iyi ele alınır.

Modern brownfield yaklaşımlar, paylaşılan ve hızlı değişen mantık için React Native'i ve performans kritik özellikler için native modülleri kullanarak bu güçlü yönleri birleştirmeyi mümkün kılar. Fabric ve TurboModules gibi yeniliklerle, React Native JavaScript odaklı mantık ile native execution arasındaki boşluğu daraltmaya devam ediyor.
